= module.import("./boolean.keli")
= module.import("./box.keli")
= module.import("./math.keli")
= module.import("./string.keli")


List.of(A Type) = tags.
    case(Nil)
    case(Cons.current(A) next(List.of(A)))

{A Type}
(x A).toString = ffi.javascript("KELI_PRELUDE$show(k$x)").as(String)

{A Type}
(this List.of(A)).toString
    | String
    = "[".++(this._toString).++("]")

{A Type}
(this List.of(A))._toString
    | String
    = this.
        case(Nil):
            ("")
        case(Cons.current(c) next(n)):
            (c.toString.++(",").++(n._toString))


"""
Get the first element of a list.
```c
//example
[1,2,3].toList.head = Box.Filled.value(1)
[].toList.head = Box.Empty
```
"""
{A Type}
(this List.of(A)).head
    | Box.of(A)
    = this.
        case(Nil):
            (Box.Empty)
        case(Cons.current(c) next(n)):
            (Box.Filled.value(c))

"""
Get the last element of a list.
```c
//example
[1,2,3].toList.last = Box.Filled.value(3)
[].toList.last = Box.Empty
```
"""
{A Type}
(this List.of(A)).last
    | Box.of(A)
    = this.
        case(Nil):
            (Box.Empty)
        case(Cons.current(c) next(n)):
            (n.
                case(Nil):
                    (Box.Filled.value(c))
                default:
                    (n.last))

"""
Get all elements of this List, except the first element.
```c
//example
[1,2,3].toList.tail = [2,3].toList
[].toList.tail = [].toList
```
"""
{A Type}
(this List.of(A)).tail
    | List.of(A)
    = this.
        case(Nil):
            (List.Nil)
        case(Cons.current(c) next(n)):
            (n)

"""
Get all the elements of this List, except the last element.
```c
//example
[1,2,3].toList.init = [1,2].toList
[].toList.init = [].toList
```
"""
{A Type}
(this List.of(A)).init
    | List.of(A)
    = this.reverse.tail.reverse

"""
Get the number of elements in this List.
```c
//example
[1,2,3].toList.length = 3
[].toList.length = 0
```
"""
{A Type}
(this List.of(A)).length 
    | Int 
    = this.
        case(Nil):
            (0)
        case(Cons.next(n)):
            (1.+(n.length))

"""
Check if this List is Empty. 
This should be used instead of using `myList.length.==(0)`, as this function is more efficient. 
```c
//example
[].toList.isEmpty = Boolean.False
[1,2].toList.isEmpty = Boolean.True
```
"""
{A Type}
(this List.of(A)).isEmpty
    | Boolean
    = this.
        case(Nil):
            (Boolean.True)
        case(Cons.current(c) next(n)):
            (Boolean.False)

"""
Add an element at the back of this List.
```c
//example
[1,2,3].toList.append(4) = [1,2,3,4].toList
```
"""
{A Type}
(this List.of(A)).append(element A) 
    | List.of(A)
    = this.
        case(Nil):
            (List.Cons.current(element) next(List.Nil))
        case(Cons.current(c) next(n)):
            (List.Cons.current(c) next(n.append(element)))


"""
Take all elements from this List that fulfils the given predicate.
```c
//example
[1,2,3,4,5].toList.where(.>(2)) = [3,4,5].toList
```
"""
{A Type}
(this List.of(A)).where(f Function.in(A) out(Boolean))
    | List.of(A)
    = this.
        case(Nil):
            (List.Nil)
        case(Cons.current(c) next(n)):
            (f.apply(c).
                case(True):
                    (List.Cons.current(c) next(n.where(f)))
                case(False):
                    (n.where(f)))

"""
Transform all elements in this List with the given function.
```c
//example
[1,2,3,4].toList.select(.*(2)) = [2,4,6,8].toList
```
"""
{A Type} {B Type}
(this List.of(A)).select(f Function.in(A) out(B))
    | List.of(B)
    = this.
        case(Nil):
            (List.Nil)
        case(Cons.current(c) next(n)):
            (List.Cons.current(f.apply(c)) next(n.select(f)))

{A Type} {B Type}
(this List.of(A)).
    select(f Function.in(A) out(B))
    where(g Function.in(A) out(Boolean))
    | List.of(B)
    = this.
        case(Nil):
            (List.Nil)
        case(Cons.current(c) next(n)):
            (g.apply(c).
                case(True):
                    (List.Cons.
                        current(f.apply(c)) 
                        next(n.select(f) where(g)))
                case(False):
                    (n.select(f) where(g)))

"""
To check if some element of this List fulfils the given predicate.
```c
//example
[1,2,3].toList.some(.>(2))  = Boolean.True
[1,2,3].toList.some(.>(10)) = Boolean.False
```
"""
{A Type}
(this List.of(A)).some(predicate Function.in(A) out(Boolean))
    | Boolean
    = this.
        case(Nil):
            (Boolean.False)
        case(Cons.current(c) next(n)):
            (predicate.apply(c).
                case(True):
                    (Boolean.True)
                case(False):
                    (n.some(predicate)))

"""
To check if every element of this List fulfils the given predicate.
```c
//example
[1,2,3].toList.every(.>(0)) = Boolean.True
[1,2,3].toList.every(.>(2)) = Boolean.False
```
"""
{A Type}
(this List.of(A)).every(predicate Function.in(A) out(Boolean))
    | Boolean
    = this.
        case(Nil):
            (Boolean.True)
        case(Cons.current(c) next(n)):
            (predicate.apply(c).
                case(True):
                    (n.every(predicate))
                case(False):
                    (Boolean.False))


"""
Concat two Lists together.
```c
//example
[1,2,3].toList.concat([4,5,6].toList) = [1,2,3,4,5,6].toList
```
"""
{A Type}
(this List.of(A)).concat(that List.of(A))
    | List.of(A)
    = this.
        case(Nil):
            (that)
        case(Cons.current(c) next(n)):
            (List.Cons.current(c) next(n.concat(that)))

"""
Reverse this List.
```c
//example
[1,2,3].toList.reverse = [3,2,1]
[].toList.reverse = []
```
"""
{A Type}
(this List.of(A)).reverse 
    | List.of(A)
    = this.
        case(Nil):
            (List.Nil)
        case(Cons.current(c) next(n)):
            (n.reverse.concat(List.Cons.current(c) next(List.Nil)))


"""
Get a range of integers.
"""
(start Int).to(end Int) 
    | List.of(Int)
    = end.<(start).
        case(True):
            (end._forwardTo(start).reverse)
        case(False):
            (start._forwardTo(end))

(start Int)._forwardTo(end Int)
    | List.of(Int)
    = end.<(start).
        case(True):
            (List.Nil)
        case(False):
            (List.Cons.current(start) next(start.+(1)._forwardTo(end)))


"""
Drop the specified number of elements from the front of this List.
```c
//example
[1,2,3].toList.drop(2) == [3].toList
```
"""
{A Type}
(this List.of(A)).drop(x Int)
    | List.of(A)
    = x.<(1).
        case(True):
            (this)
        case(False):
            ((this.
                case(Nil):
                    (List.Nil)
                case(Cons.current(c) next(n)):
                    (n.drop(x.-(1)))))

"""
Take the specified number of elements from the front of this List.

```c
//example
[1,2,3,4,5].toList.take(3) = [1,2,3].toList
```
"""
{A Type}
(this List.of(A)).take(x Int)
    | List.of(A)
    = this.reverse.drop(this.length.-(x)).reverse

"""
Take elements from index `a` until inlcuding index `b` from a List.
```
//example
[9,8,7,6,5].from(1) to(3) return [8,7,6]
```
"""
{A Type}
(this List.of(A)).from(a Int) to(b Int)
    | List.of(A)
    = this.drop(a).take(b.-(a).+(1))


"Convert this Array to List."
{A Type}
(this Array.of(A)).toList 
    = ffi.javascript("""
    (() => {
        const result = k$List.Cons({current:k$this[0],next:k$List.Nil});
        let current = result;
        for(let i=1;i<k$this.length;i++){
            current.next = k$List.Cons({current:k$this[i],next:k$List.Nil});
            current = current.next;
        }
        return result;
    })()
    """).as(List.of(A))


"""
Partition this List by a predicate.
```c
//example
[1,2,3,4].toList.partitionBy(.>(2)) = object.included([3,4].toList) excluded([1,2].toList)
```
"""
{A Type}
(this List.of(A)).partitionBy(f Function.in(A) out(Boolean))
    | object.included(List.of(A)) excluded(List.of(A))
    = this._partitionBy(f) startingFilled(object.included(List.Nil) excluded(List.Nil))

{A Type}
(this List.of(A)).
    _partitionBy(f Function.in(A) out(Boolean))
    startingFilled(previousResult object.included(List.of(A)) excluded(List.of(A)))
    | object.included(List.of(A)) excluded(List.of(A))
    = this.
        case(Nil):
            (previousResult)
        case(Cons.current(c) next(n)):
            (f.apply(c).
                case(True):
                    (n._partitionBy(f) startingFilled(previousResult.included(.append(c))))
                case(False):
                    (n._partitionBy(f) startingFilled(previousResult.excluded(.append(c)))))

"""
Return the leftmost element in this List that satisfies the given predicate.
```c
//example
[1,2,3].toList.find(.>(1)) = Box.Filled.value(2)
```
"""
{A Type}
(this List.of(A)).find(p Function.in(A) out(Boolean))
    | Box.of(A)
    = this.
        case(Nil):
            (Box.Empty)
        case(Cons.current(c) next(n)):
            (p.apply(c).
                case(True):
                    (Box.Filled.value(c))
                case(False):
                    (n.find(p)))